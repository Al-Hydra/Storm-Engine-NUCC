//------------------------------------------------
//--- 010 Editor v10.0.2 Binary Template
//
//      File: nucc.bt
//   Authors: SutandoTsukai181
//   Version: 1.3
//   Purpose: Contains structs for parsing nuccChunks inside Xfbin files
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//   1.0 - Initial release
//   1.1 - Added nuccChunkCoord struct
//   1.2 - Added nuccChunkClump and nuccChunkModel structs
//   1.3 - Added nuccChunkModelHit and updated nuccChunkDynamics
//------------------------------------------------

#include "/../include.h"
#include "nuccChunkAnm.bt"
#include "nuccChunkAnmStrm.bt"
#include "nuccChunkAnmStrmFrame.bt"
#include "nuccChunkFont.bt"
#include "nuccChunkBillboard.bt"
#include "nuccChunkParticle.bt"
#include "nut.bt"


local uint currentPageIndex = 0;
typedef struct
{
    u32 PageSize;
    if ( parentof(parentof(parentof(parentof(this)))).Version > 96 )
    
    {
        u32 ExtraIndicesSize;
    }
    else
    {
        local uint ExtraIndicesSize = 0;
    }

} TNuccPage;

typedef struct
{
    u16 Field00;
    u16 Width;
    u16 Height;
    u16 Field06;

    u32 Size;

    #ifdef NUT
        FPushBase();
        {
            TNut Nut;
        }
        FPopBase();
    #else
        u8 Data[Size];
    #endif
} TNuccTexture;

typedef struct
{
    u16 morphTargetCount;
    u16 flags;
    s32 modelIndex;
    f32 value;
    struct{
        s32 targetIndex;
        f32 value;
    }targets[morphTargetCount];
    
} TNuccMorphModel;

typedef struct
{
    u16 morphTargetCount;
    u16 flags;
    s32 modelIndex;
    s32 batchIndex;
    f32 value;
    struct{
        s32 targetIndex;
        f32 value;
        s32 unk;
    }targets[morphTargetCount];
        
} TNuccMorphPrimitive;

typedef struct
{
    u32 modelSize;
    u8 model[modelSize];
} TNuccModelVertex;

typedef struct
{
    u16 GroupCount;
    u16 Alpha;
    f32 Glare;
    u32 MaterialFlags;

    if ( MaterialFlags & 0x01 )
    {
    struct{
        f32 uvOffset0[4];
        }uvOffset0 <read = Str("(%f, %f, %f, %f)",this.uvOffset0[0],this.uvOffset0[1],this.uvOffset0[2],this.uvOffset0[3])>;
    }
    if ( MaterialFlags & 0x02 )
    {
        struct{
            f32 uvOffset1[4];
        }uvOffset1 <read = Str("(%f, %f, %f, %f)",this.uvOffset1[0],this.uvOffset1[1],this.uvOffset1[2],this.uvOffset1[3])>;
    }
    
    if ( MaterialFlags & 0x04 )
    {
        struct{
            f32 uvOffset2[4];
        }uvOffset2 <read = Str("(%f, %f, %f, %f)",this.uvOffset2[0],this.uvOffset2[1],this.uvOffset2[2],this.uvOffset2[3])>;
    }
    
    if ( MaterialFlags & 0x08 )
    {
        struct{
            f32 uvOffset3[4];
        }uvOffset3 <read = Str("(%f, %f, %f, %f)",this.uvOffset3[0],this.uvOffset3[1],this.uvOffset3[2],this.uvOffset3[3])>;
    }
    
    if ( MaterialFlags & 0x10 )
    {
        struct{
            f32 blendRate[2];
        }blendRate <read = Str("(%f, %f)",this.blendRate[0],this.blendRate[1])>;
    }
    if ( MaterialFlags & 0x20 ) f32 falloff;
    if ( MaterialFlags & 0x40 ) f32 outlineID;

    local u32 i, j;
    for ( i = 0; i < GroupCount; i++ )
    {
        struct
        {
            s16 TextureCount;
            u16 Field22;
            u32 Field24;
    
            u32 TextureChunkIndices[TextureCount];
    
            if ( exists( Xfbin ) )
            {
                struct
                {
                    FPush();
                    {
                        for ( j = 0; j < TextureCount; j++ )
                        {
                            FSeekRel( startof( Xfbin.ChunkTable.ChunkMaps[GetChunkMapIndex(
                                TextureChunkIndices[j],
                                parentof(parentof(parentof(parentof(this)))).pageStart
                            )] ) );
                            struct TChunkMap ChunkMap;
                        }
                    }
                    FPop();
                } TextureChunks;
            }
        } TextureGroup;
    }
} TNuccMaterial <optimize=false>;

typedef struct
{
    u16 SpringGroupsCount;
    u16 CollisionSpheresCount;

    u32 ClumpChunkIndex;

    local int i, j, bonesCount = 0;
    for ( i = 0; i < SpringGroupsCount; i++ )
    {
        struct
        {
            f32 Bounciness;
            f32 Elasticity;
            f32 Stiffness;
            f32 Movement;
            u16 CoordIndex;
            u16 BonesCount;
            bonesCount += BonesCount;
        } SpringGroup;
    }

    for ( i = 0; i < CollisionSpheresCount; i++ )
    {
        struct
        {
            f32 OffsetZ;
            f32 OffsetY;
            f32 OffsetX;
            f32 ScaleZ;
            f32 ScaleY;
            f32 ScaleX;

            u16 CoordIndex;
            u16 AttachSpringGroupFlag;

            s16 Unk;
            u16 Padding2;

            for ( j = 0; j < AttachSpringGroupFlag; j++ )
            {
                u16 AttachedSpringGroupsCount;
                u16 SpringGroupIndex[AttachedSpringGroupsCount];
            }
        } CollisionSphere;
    }

    u16 SpringBonesFlags[bonesCount];
} TNuccDynamics <optimize=false>;

typedef struct
{
    f32 LocX;
    f32 LocY;
    f32 LocZ;

    f32 RotX;
    f32 RotY;
    f32 RotZ;

    f32 ScaleX;
    f32 ScaleY;
    f32 ScaleZ;
    f32 UnkFloat;

    if ( parentof(this).Version >= 0x68 )
    {
        u16 UnkShort;
    }
} TNuccCoord;

typedef struct
{

// Please ignore the incorrect indentation here in favor of having a cleaner git diff
if ( parentof(this).Version != 0x79 && parentof(this).Version != 0x7A )
{
    u8 Data[parentof(this).Size];
}
else
{

    u32 flags; // Not always 0

    u16 CoordCount;
    u8 lodGroupCount;
    u8 lodUnkCount;

    if ( flags == 2 )
    {
        f32 BoundingBox[6];
        u32 unkBB;
    }

    s16 CoordNodeParents[CoordCount];
    u32 CoordNodeIndices[CoordCount];

    // This only lists the parents, not the node whose parent is listed
    local int i;
    struct
    {
        local u32 currentIndex;
        for ( i = 0; i < CoordCount; i++ )
        {
            FPush();
            {
                currentIndex = CoordNodeParents[i] < 0 ? 0 : CoordNodeIndices[CoordNodeParents[i]];
                FSeekRel( startof( Xfbin.ChunkTable.ChunkMaps[GetChunkMapIndex(
                    i,
                    parentof(parentof(parentof(this))).pageStart
                )] ) );
                struct TChunkMap ChunkMap;
            }
            FPop();
        }
    } CoordNodeParentsChunks;

    struct
    {
        for ( i = 0; i < CoordCount; i++ )
        {
            FPush();
            {
                FSeekRel( startof( Xfbin.ChunkTable.ChunkMaps[GetChunkMapIndex(
                    CoordNodeIndices[i],
                    parentof(parentof(parentof(this))).pageStart
                )] ) );
                struct TChunkMap ChunkMap;
            }
            FPop();
        }
    } CoordNodeIndicesChunks;
    
    
    struct{
    
        u16 ModelCount;
        u8 unkFlags[2];
        f32 lodThreshold;
        u32 ModelIndices[ModelCount];
        struct
        {
            for ( i = 0; i < ModelCount; i++ )
            {
                FPush();
                {
                    FSeekRel( startof( Xfbin.ChunkTable.ChunkMaps[GetChunkMapIndex(
                        ModelIndices[i],
                        parentof(parentof(parentof(parentof(this)))).pageStart
                    )] ) );
                    struct TChunkMap ChunkMap;
                }
                FPop();
            }
        } ModelIndicesChunks;
    }lodGroups[lodGroupCount]<optimize = false>;
    
    struct{
        
        u16 ModelCount;
        u8 unkFlags[2];
        f32 lodThreshold;
        u32 ModelIndices[ModelCount];
        struct
        {
            for ( i = 0; i < ModelCount; i++ )
            {
                FPush();
                {
                    FSeekRel( startof( Xfbin.ChunkTable.ChunkMaps[GetChunkMapIndex(
                        ModelIndices[i],
                        parentof(parentof(parentof(parentof(this)))).pageStart
                    )] ) );
                    struct TChunkMap ChunkMap;
                }
                FPop();
            }
        } ModelIndicesChunks;
    }unkGroups[lodUnkCount];
    
    if ( parentof(this).Version >= 0x73 )
    {
        s16 unkValue;    
    }
    
/*
    u16 ModelCount;
    u8  ModelFlags[2]; // Not always 0

    u32 Padding;
    u32 ModelIndices[ModelCount];

    struct
    {
        for ( i = 0; i < ModelCount; i++ )
        {
            FPush();
            {
                FSeekRel( startof( Xfbin.ChunkTable.ChunkMaps[GetChunkMapIndex(
                    ModelIndices[i],
                    parentof(parentof(parentof(this))).pageStart
                )] ) );
                struct TChunkMap ChunkMap;
            }
            FPop();
        }
    } ModelIndicesChunks;

    do
    {
        struct TNuccClumpModelGroup ModelGroup;
    } while ( ModelGroup.Count != -1 && (FTell() - startof(this)) < parentof(this).Size );
*/
}
} TNuccClump <optimize=false>;

typedef struct
{
    s16 Count;

    if ( Count != -1 && (FTell() - startof(parentof(this))) < parentof(parentof(this)).Size )
    {
        u8 Flags[2];

        f32 lodThreshold;
        s32 Indices[Count];

        struct
        {
            local u32 currentIndex;
            for ( i = 0; i < Count; i++ )
            {
                FPush();
                {
                    currentIndex = Indices[i];
                    if ( currentIndex == -1 )
                        currentIndex = 0;

                    FSeekRel( startof( Xfbin.ChunkTable.ChunkMaps[GetChunkMapIndex(
                        currentIndex,
                        parentof(parentof(parentof(parentof(this)))).pageStart
                    )] ) );
                    struct TChunkMap ChunkMap;
                }
                FPop();
            }
        } ModelGroupChunks;
    }
} TNuccClumpModelGroup;

typedef struct
{
    struct Header
    {
       u32 MeshCount;
       u32 TrianglesCount;

    } HitHeader <bgcolor=0xc01b7b>;
    
    
    local int i, j;
    for (i = 0; i < HitHeader.MeshCount; i++)
    {
        struct VertexSection
        {
            struct MeshHeader
            {
                u32 TrianglesCount;
                u32 Flags <format = hex>;

                if (parentof(parentof(parentof(this))).Version > 0x79) 
                {
                    FSkip(8);
                }

            } meshHeader;

            for (j = 0; j < meshHeader.TrianglesCount; j++)
            {
                struct{
                    struct
                    {
                        f32 x;
                        f32 y;
                        f32 z;
                    } Vertices[3] <bgcolor=0xFFDF35>;
                }Triangle;
            }


        } Mesh <bgcolor=0xFFCF36>;
    
    }
                       
} TNuccModelHit;

typedef struct
{
    s32 ClumpID;
    s32 MaterialID;
    s32 PrimitiveVertexChunkID;
    u32 Padding;
    u16 meshCount;
    u16 vertexChunkCount;
    u32 unk1;
    u16 unk2;
    u16 unk3;
    u32 unk4;
    //u8 unknowndata[16];
    u32 unk5;
    u32 ShaderID <format = hex>;
    u32 unk6;
    u32 unk7;
    f32 unk8;
    struct
    {
        u32 EntryID;
        u32 VertexCount;
        u32 padding;
    }VertexChunks[meshCount];
        
                       
} TNuccModelPremitiveBatch;

typedef struct
{
    u32 BatchChunkIndex;
    u32 VertexType;
    u32 VertexSize;
    u32 VertexCount;
    local int i;
    switch (VertexType)
    {
        case 0:

            for (i = 0; i < VertexCount; i++)
            {
                struct{
                    struct{
                        f32 Pos_X;
                        f32 Pos_Y;
                        f32 Pos_Z;
                        u32 Padding;
                    }VertexPosition;
                    struct{
                        f32 Normal_X;
                        f32 Normal_Y;
                        f32 Normal_Z;
                        u32 Padding;
                    }VertexNormal;
                    struct{
                        f32 R;
                        f32 G;
                        f32 B;
                        f32 A;
                    }VertexColor;
                    struct{
                        f32 U;
                        f32 V;
                        u64 Padding;
                    }VertexUV;
                }VertexStruct;
            }
        break;
        
        case 1:
            for (i = 0; i < VertexCount; i++)
            {
                struct{
                    struct{
                        f32 Pos_X;
                        f32 Pos_Y;
                        f32 Pos_Z;
                        u32 Padding;
                    }VertexPosition;
                    struct{
                        f32 Normal_X;
                        f32 Normal_Y;
                        f32 Normal_Z;
                        u32 Padding;
                    }VertexNormal;
                    struct{
                        f32 U;
                        f32 V;
                        u64 Padding;
                    }VertexUV;
                }VertexStruct;
            }
        break;
        
        case 2:
            
            for (i = 0; i < VertexCount; i++)
        {
            struct{
                struct{
                    f32 Pos_X;
                    f32 Pos_Y;
                    f32 Pos_Z;
                    u32 Padding;
                }VertexPosition;
                struct{
                    f32 R;
                    f32 G;
                    f32 B;
                    f32 A;
                }VertexColor;
                struct{
                    f32 U;
                    f32 V;
                    u64 Padding;
                }VertexUV;
            }VertexStruct;
        }
        break;
        
        case 3:
            
            for (i = 0; i < VertexCount; i++)
        {
            struct{
                struct{
                    f32 Pos_X;
                    f32 Pos_Y;
                    f32 Pos_Z;
                    u32 Padding;
                }VertexPosition;
                struct{
                    f32 U;
                    f32 V;
                    u64 Padding;
                }VertexUV;
            }VertexStruct;
        }
        break;
    }
} TNuccPrimitiveVertex;


typedef struct
{
    if (parentof(this).Version < 0x74)
    {
        u16 Unk1; //Increasing this value requires you to add 2 more bytes in the header
        u16 MaterialFlags;
    
        u16 Attributes;
        u8 RenderLayer;
        u8 LightModeID;
        u32 ClumpID;
        u32 HitID;
        u32 MeshBoneID;
        u32 NUDSize;
        
    }
    else if (parentof(this).Version > 0x73 && parentof(this).Version < 0x76)
    {
        u16 Unk1; //Increasing this value requires you to add 2 more bytes in the header
        u16 MaterialFlags;
    
        u16 Attributes;
        u8 unk1;
        u8 unk2;
        u32 ClumpID;
        u32 HitID;
        s32 MeshBoneID;
        u32 NUDSize;
        u16 LightCategoryFlag;
        u8 RenderLayer;
        u8 LightModeID;
        
    }
    else
    {
        u16 Unk1; //Increasing this value requires you to add 2 more bytes in the header
        u16 MaterialFlags;
    
        u16 Attributes;
        u8 RenderLayer;
        u8 LightModeID;
        
        {u32 LightCategoryFlag;}
    
        u32 ClumpID;
        u32 HitID;
        s32 MeshBoneID;
        u32 NUDSize;
    }

    if (Attributes & 0x4)
            {f32 BoundingBox[6];}
        
        u8 NUD[NUDSize];
        u16 MaterialCount;
        u32 MaterialIDs[MaterialCount];
     
} TNuccModelChunk;


typedef struct
{
    f32 unk[4];
    f32 color[4];
    f32 unk2[4];
    f32 rotation[4];
                       
} LightDirc;

typedef struct
{
    u32 hashes[4];
    f32 color[4];
    f32 position[4];
    f32 parameters[4];
                       
} LightPoint;
